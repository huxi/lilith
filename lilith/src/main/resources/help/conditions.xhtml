<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
	PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>Conditions</title>
	<link href="help.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p><a href="index.xhtml">ToC</a></p>

<h1><a name="top">Conditions</a></h1>

<p>
	Lilith supports several types of conditions:
</p>
<ul>
	<li>event.contains<br/>
		This is generally the most desired case. It checks if any field of the event contains the given string.
		While being the most general, it's also the one with the poorest performance, for the same reason.<br/>
		This condition is the default condition of the search panel.
	</li>
	<li>message.contains<br/>
		Checks only if the message of the logging event contains the given string.<br/>
		It will only return a positive result in case of logging events because access events don't have
		a message.
	</li>
	<li>logger.startsWith<br/>
		Checks only if the logger name of the logging event starts with the given string.<br/>
		This condition is useful to select a subset of events based on the package name of the logging class.<br/>
		It will only return a positive result in case of logging events because access events don't have
		a logger name.
	</li>
	<li>logger.equals<br/>
		Checks only if the logger name of the logging event equals the given string.<br/>
		It will only return a positive result in case of logging events because access events don't have
		a logger name.
	</li>
	<li><a href="#saved">Saved conditions</a></li>
	<li><a href="#groovy">Custom Groovy conditions</a></li>
</ul>
<p><a href="#top">Back to top.</a></p>

<h2><a name="saved">Saved conditions</a></h2>

<p>It's possible to save conditions using "View" =&gt; "Add condition...".
	The shortcut for this functionality is *command*-I.<br/>
	Such saved conditions can be (re)used by entering "#condition#&lt;conditionName&gt;" into the search box.</p>

<p>Beside that, saved conditions also have the effect that their name is used as the title of a
	filtered views tab instead of the (most likely much longer) string representation of the condition.</p>

<p><a href="#top">Back to top.</a></p>

<h2><a name="groovy">Custom Groovy conditions</a></h2>

<p>It is possible to create complex conditions in Groovy.
	The scripts must be created in "[lilith.home]/conditions" and must have a ".groovy" extension.</p>

<p>By default, [lilith.home] equals [user.home]/.lilith but this can be changed
	in preferences.</p>

<p>A condition script receives an event-wrapper as the environment variable "input" and is
	expected to return either true or false. Additionally, the string entered in the text field of the
	search panel is available in the variable "searchText".</p>

<p>The scripts can then be used by either entering "#groovy#&lt;filename without extension&gt;" or
	"#groovy#&lt;filename without extension&gt;#the text to search for" into
	the search box. After entering the "#groovy#"-prefix, the color of the textfield will indicate if
	a script of the given name exists.</p>

<p>See <a href="http://groovy.codehaus.org/">http://groovy.codehaus.org/</a> for help on Groovy.</p>

<h3>Relevant javadocs</h3>
<ul>
	<li><a href="http://lilith.huxhorn.de/projects/de.huxhorn.lilith.data.eventsource/apidocs/index.html">EventWrapper and related classes</a></li>
	<li><a href="http://lilith.huxhorn.de/projects/de.huxhorn.lilith.data.logging/apidocs/index.html">LoggingEvent and related classes</a></li>
	<li><a href="http://lilith.huxhorn.de/projects/de.huxhorn.lilith.data.access/apidocs/index.html">AccessEvent and related classes</a></li>
</ul>

<h3>Example 1: Match only odd events.</h3>
<pre><code>input.localId % 2 == 1</code></pre>

<h3>Example 2: Match events having a threadName that's starting with the given search string.</h3>
    <pre><code>/**
 * Returns true if the logging event has a thread name that
 * starts with the given searchString.
 */
import de.huxhorn.lilith.data.logging.LoggingEvent;

def event = input?.event;

if(event instanceof LoggingEvent)
{
  def threadName = event.threadInfo?.name;
  if(threadName)
  {
    return threadName.startsWith(searchString);
  }
}
return false;</code></pre>

<h3>Example 3: Match logging events with a level higher or equal to the one given as searchString</h3>
<pre><code>/**
 * Returns true if the logging event has a level higher or equal to the
 * one provided with the searchString.
 */
import de.huxhorn.lilith.data.logging.LoggingEvent;

def event = input?.event;

if(searchString == null || '' == searchString)
{
  // so no string doesn't filter anything
  return true;
}

if(event instanceof LoggingEvent)
{
  def level = event.level;

  if(level)
  {
    try
    {
      def threshold=LoggingEvent.Level.valueOf(searchString);
      if(level >= threshold)
      {
        return true;
      }
    }
    catch(IllegalArgumentException ex)
    {
      // ignore
    }
  }
}
return false;</code></pre>

<h3>Example 4: Match logging events with a message matching the regex given as searchString</h3>
<pre><code>/**
 * Returns true if the logging events message matches the regex 
 * given as searchString.
 */
import de.huxhorn.lilith.data.logging.LoggingEvent;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

def event = input?.event;

if(searchString == null || '' == searchString)
{
  // so no string doesn't filter anything
  return true;
}

if(event instanceof LoggingEvent)
{
  try
  {
    def pattern = Pattern.compile(searchString);
    def message = event.message.message;
    if(message)
    {
      return message ==~ pattern; // short for pattern.matcher(message).matches();
    }
  }
  catch(PatternSyntaxException ex)
  {
    // ignore, returns false
  }
}
return false;</code></pre>

<p><a href="#top">Back to top.</a></p>
</body>
</html>
