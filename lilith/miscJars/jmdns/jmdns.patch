Index: javax/jmdns/impl/JmDNSImpl.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/JmDNSImpl.java,v
retrieving revision 1.4
diff -u -r1.4 JmDNSImpl.java
--- javax/jmdns/impl/JmDNSImpl.java	21 May 2008 21:00:23 -0000	1.4
+++ javax/jmdns/impl/JmDNSImpl.java	29 Jun 2008 15:48:13 -0000
@@ -4,6 +4,19 @@
 
 package javax.jmdns.impl;
 
+import javax.jmdns.JmDNS;
+import javax.jmdns.ServiceEvent;
+import javax.jmdns.ServiceInfo;
+import javax.jmdns.ServiceListener;
+import javax.jmdns.ServiceTypeListener;
+import javax.jmdns.impl.tasks.Announcer;
+import javax.jmdns.impl.tasks.Prober;
+import javax.jmdns.impl.tasks.RecordReaper;
+import javax.jmdns.impl.tasks.Renewer;
+import javax.jmdns.impl.tasks.Responder;
+import javax.jmdns.impl.tasks.ServiceInfoResolver;
+import javax.jmdns.impl.tasks.ServiceResolver;
+import javax.jmdns.impl.tasks.TypeResolver;
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.InetAddress;
@@ -23,21 +36,6 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.jmdns.JmDNS;
-import javax.jmdns.ServiceEvent;
-import javax.jmdns.ServiceInfo;
-import javax.jmdns.ServiceListener;
-import javax.jmdns.ServiceTypeListener;
-import javax.jmdns.impl.tasks.Announcer;
-import javax.jmdns.impl.tasks.Canceler;
-import javax.jmdns.impl.tasks.Prober;
-import javax.jmdns.impl.tasks.RecordReaper;
-import javax.jmdns.impl.tasks.Renewer;
-import javax.jmdns.impl.tasks.Responder;
-import javax.jmdns.impl.tasks.ServiceInfoResolver;
-import javax.jmdns.impl.tasks.ServiceResolver;
-import javax.jmdns.impl.tasks.TypeResolver;
-
 // REMIND: multiple IP addresses
 
 /**
@@ -309,18 +307,28 @@
             try
             {
                 socket.leaveGroup(group);
-                socket.close();
-                if (incomingListener != null)
-                {
-                    incomingListener.join();
-                }
             }
-            catch (final Exception exception)
+            catch (IOException exception)
             {
-                logger.log(Level.WARNING, "closeMulticastSocket() Close socket exception ",
+                logger.log(Level.WARNING, "closeMulticastSocket() Leave group socket exception ",
                         exception);
             }
+			finally
+			{
+				socket.close();
+			}
             socket = null;
+			try
+			{
+				if (incomingListener != null)
+				{
+					incomingListener.join();
+				}
+			}
+			catch(InterruptedException ex)
+			{
+				// ignore
+			}
         }
     }
 
@@ -510,8 +518,7 @@
     }
 
     /**
-     * @see javax.jmdns.JmDNS#removeServiceTypeListener(javax.jmdns.
-     *  ServiceTypeListener)
+     * @see javax.jmdns.JmDNS#removeServiceTypeListener(javax.jmdns.ServiceTypeListener)
      */
     public void removeServiceTypeListener(ServiceTypeListener listener)
     {
@@ -529,7 +536,7 @@
     {
         final String lotype = type.toLowerCase();
         removeServiceListener(lotype, listener);
-        List list = null;
+        List list;
 
         synchronized (serviceListeners)
         {
@@ -642,14 +649,18 @@
         }
         info.cancel();
 
-        // Note: We use this lock object to synchronize on it.
-        // Synchronizing on another object (e.g. the ServiceInfo) does
-        // not make sense, because the sole purpose of the lock is to
-        // wait until the canceler has finished. If we synchronized on
-        // the ServiceInfo or on the Canceler, we would block all
-        // accesses to synchronized methods on that object. This is not
-        // what we want!
-        final Object lock = new Object();
+		CancelRunnable cancel=new CancelRunnable(info);
+		executeCancel(cancel);
+
+/*
+		// Note: We use this lock object to synchronize on it.
+        //       Synchronizing on another object (e.g. the ServiceInfo) does
+        //       not make sense, because the sole purpose of the lock is to
+        //       wait until the canceler has finished. If we synchronized on
+        //       the ServiceInfo or on the Canceler, we would block all
+        //       accesses to synchronized methods on that object. This is not
+        //       what we want!
+        Object lock = new Object();
         new Canceler(this, info, lock).start(timer);
 
         // Remind: We get a deadlock here, if the Canceler does not run!
@@ -664,6 +675,7 @@
         {
             // empty
         }
+*/
     }
 
     /**
@@ -688,7 +700,10 @@
             ((ServiceInfoImpl) iterator.next()).cancel();
         }
 
-        final Object lock = new Object();
+		CancelRunnable cancel=new CancelRunnable(list);
+		executeCancel(cancel);
+		/*
+		Object lock = new Object();
         new Canceler(this, list, lock).start(timer);
         // Remind: We get a livelock here, if the Canceler does not run!
         try
@@ -705,33 +720,53 @@
         {
             // empty
         }
+        */
 
     }
 
-    /**
-     * @see javax.jmdns.JmDNS#registerServiceType(java.lang.String)
-     */
-    public void registerServiceType(String type)
-    {
-        final String name = type.toLowerCase();
-        if (serviceTypes.get(name) == null)
-        {
-            if ((type.indexOf("._mdns._udp.") < 0) && !type.endsWith(".in-addr.arpa."))
-            {
-                Collection list;
-                synchronized (this)
-                {
-                    serviceTypes.put(name, type);
-                    list = new LinkedList(typeListeners);
-                }
-                for (final Iterator iterator = list.iterator(); iterator.hasNext();)
-                {
-                    ((ServiceTypeListener) iterator.next()).serviceTypeAdded(new ServiceEventImpl(
-                            this, type, null, null));
-                }
-            }
-        }
-    }
+	private void executeCancel(CancelRunnable cancel)
+	{
+		/*
+		Thread cancelThread=new Thread(cancel, "CancelThread");
+		cancelThread.setDaemon(false);
+		cancelThread.start();
+		try
+		{
+			cancelThread.join();
+		}
+		catch (InterruptedException e)
+		{
+			logger.fine("CancelThread was interrupted.");
+		}
+		*/
+		logger.fine("Starting to execute cancel.");
+		cancel.run();
+		logger.fine("Finished executing cancel.");
+	}
+
+	/**
+	 * @see javax.jmdns.JmDNS#registerServiceType(java.lang.String)
+	 */
+	public void registerServiceType(String type)
+	{
+		String name = type.toLowerCase();
+		if (serviceTypes.get(name) == null)
+		{
+			if ((type.indexOf("._mdns._udp.") < 0) && !type.endsWith(".in-addr.arpa."))
+			{
+				Collection list;
+				synchronized (this)
+				{
+					serviceTypes.put(name, type);
+					list = new LinkedList(typeListeners);
+				}
+				for (Iterator iterator = list.iterator(); iterator.hasNext();)
+				{
+					((ServiceTypeListener) iterator.next()).serviceTypeAdded(new ServiceEventImpl(this, type, null, null));
+				}
+			}
+		}
+	}
 
     /**
      * Generate a possibly unique name for a host using the information we have
@@ -899,7 +934,7 @@
     {
         // We do not want to block the entire DNS while we are updating the
         // record for each listener (service info)
-        List listenerList = null;
+        List listenerList;
         synchronized (this)
         {
             listenerList = new ArrayList(listeners);
@@ -911,7 +946,7 @@
         }
         if (rec.type == DNSConstants.TYPE_PTR || rec.type == DNSConstants.TYPE_SRV)
         {
-            List serviceListenerList = null;
+            List serviceListenerList;
             synchronized (serviceListeners)
             {
                 serviceListenerList = (List) serviceListeners.get(rec.name.toLowerCase());
@@ -1001,7 +1036,7 @@
                     {
                         if (!expired && rec.name.startsWith("_services._mdns._udp."))
                         {
-                            isInformative = true;
+                            //isInformative = true;
                             registerServiceType(((DNSRecord.Pointer) rec).alias);
                         }
                         continue;
@@ -1143,9 +1178,15 @@
 
     public void schedule(TimerTask task, int delay)
     {
-        timer.schedule(task, delay);
-    }
-
+        try
+		{
+			timer.schedule(task, delay);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}
+	}
     // REMIND: Why is this not an anonymous inner class?
     /**
      * Shutdown operations.
@@ -1267,8 +1308,8 @@
         {
             for (final Iterator k = services.keySet().iterator(); k.hasNext();)
             {
-                final Object key = k.next();
-                aLog.append("\n\t\tService: " + key + ": " + services.get(key));
+                Object key = k.next();
+				aLog.append("\n\t\tService: ").append(key).append(": ").append(services.get(key));
             }
         }
         aLog.append("\n");
@@ -1277,8 +1318,8 @@
         {
             for (final Iterator k = serviceTypes.keySet().iterator(); k.hasNext();)
             {
-                final Object key = k.next();
-                aLog.append("\n\t\tType: " + key + ": " + serviceTypes.get(key));
+                Object key = k.next();
+				aLog.append("\n\t\tType: ").append(key).append(": ").append(serviceTypes.get(key));
             }
         }
         aLog.append("\n");
@@ -1291,9 +1332,8 @@
             {
                 for (final Iterator k = serviceCollectors.keySet().iterator(); k.hasNext();)
                 {
-                    final Object key = k.next();
-                    aLog.append("\n\t\tService Collector: " + key + ": "
-                            + serviceCollectors.get(key));
+                    Object key = k.next();
+					aLog.append("\n\t\tService Collector: ").append(key).append(": ").append(serviceCollectors.get(key));
                 }
                 serviceCollectors.clear();
             }
@@ -1345,7 +1385,8 @@
             }
             catch (final InterruptedException e)
             {
-            }
+				// ignore
+			}
         }
 
         return collector.list();
@@ -1379,7 +1420,7 @@
      */
     private static class ServiceCollector implements ServiceListener
     {
-        private static Logger logger = Logger.getLogger(ServiceCollector.class.getName());
+        //private static Logger logger = Logger.getLogger(ServiceCollector.class.getName());
         /**
          * A set of collected service instance names.
          */
@@ -1446,13 +1487,13 @@
             {
                 for (final Iterator k = infos.keySet().iterator(); k.hasNext();)
                 {
-                    final Object key = k.next();
-                    aLog.append("\n\t\tService: " + key + ": " + infos.get(key));
+                    Object key = k.next();
+					aLog.append("\n\t\tService: ").append(key).append(": ").append(infos.get(key));
                 }
             }
             return aLog.toString();
         }
-    };
+    }
 
     private static String toUnqualifiedName(String type, String qualifiedName)
     {
@@ -1560,4 +1601,67 @@
     {
         return group;
     }
+
+
+	/**
+	 * The Canceler sends two announces with TTL=0 for the specified services.
+	 */
+	private class CancelRunnable
+		implements Runnable
+	{
+		private Logger logger = Logger.getLogger(CancelRunnable.class.getName());
+		/**
+		 * The services that need cancelling.
+		 * Note: We have to use a local variable here, because the services
+		 * that are canceled, are removed immediately from variable JmDNS.services.
+		 */
+		private ServiceInfoImpl[] infos;
+
+		public CancelRunnable(ServiceInfoImpl info)
+		{
+			this.infos = new ServiceInfoImpl[]{info};
+			JmDNSImpl.this.addListener(info, new DNSQuestion(info.getQualifiedName(), DNSConstants.TYPE_ANY, DNSConstants.CLASS_IN));
+		}
+
+		public CancelRunnable(ServiceInfoImpl[] infos)
+		{
+			this.infos = infos;
+		}
+
+		public CancelRunnable(Collection infos)
+		{
+			this.infos = (ServiceInfoImpl[]) infos.toArray(new ServiceInfoImpl[infos.size()]);
+		}
+
+		public void run()
+		{
+			final int ttl=0;
+			try
+			{
+				for(int counter=0;counter<3;counter++)
+				{
+					logger.finer("run() JmDNS canceling service");
+					// announce the service
+					//long now = System.currentTimeMillis();
+					DNSOutgoing out = new DNSOutgoing(DNSConstants.FLAGS_QR_RESPONSE | DNSConstants.FLAGS_AA);
+					for (int i = 0; i < infos.length; i++)
+					{
+						ServiceInfoImpl info = infos[i];
+						info.addAnswers(out, ttl, JmDNSImpl.this.getLocalHost());
+
+						JmDNSImpl.this.getLocalHost().addAddressRecords(out, false);
+					}
+					JmDNSImpl.this.send(out);
+					Thread.sleep(DNSConstants.ANNOUNCE_WAIT_INTERVAL);
+				}
+				JmDNSImpl.this.setClosed(true);
+				logger.finer("run() JmDNS canceling service finished!");
+			}
+			catch (Throwable e)
+			{
+				logger.log(Level.WARNING, "run() JmDNS canceling service exception ", e);
+				JmDNSImpl.this.recover();
+			}
+		}
+	}
 }
Index: javax/jmdns/impl/tasks/Announcer.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/Announcer.java,v
retrieving revision 1.1
diff -u -r1.1 Announcer.java
--- javax/jmdns/impl/tasks/Announcer.java	6 Feb 2008 21:42:40 -0000	1.1
+++ javax/jmdns/impl/tasks/Announcer.java	1 Mar 2008 13:37:07 -0000
@@ -4,6 +4,11 @@
 
 package javax.jmdns.impl.tasks;
 
+import javax.jmdns.impl.DNSConstants;
+import javax.jmdns.impl.DNSOutgoing;
+import javax.jmdns.impl.DNSState;
+import javax.jmdns.impl.JmDNSImpl;
+import javax.jmdns.impl.ServiceInfoImpl;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -12,12 +17,6 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.jmdns.impl.DNSConstants;
-import javax.jmdns.impl.DNSOutgoing;
-import javax.jmdns.impl.DNSState;
-import javax.jmdns.impl.JmDNSImpl;
-import javax.jmdns.impl.ServiceInfoImpl;
-
 /**
  * The Announcer sends an accumulated query of all announces, and advances
  * the state of all serviceInfos, for which it has sent an announce.
@@ -62,8 +61,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.ANNOUNCE_WAIT_INTERVAL, DNSConstants.ANNOUNCE_WAIT_INTERVAL);
-    }
+		try
+		{
+			timer.schedule(this, DNSConstants.ANNOUNCE_WAIT_INTERVAL, DNSConstants.ANNOUNCE_WAIT_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}
+	}
 
     public boolean cancel()
     {
Index: javax/jmdns/impl/tasks/Prober.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/Prober.java,v
retrieving revision 1.1
diff -u -r1.1 Prober.java
--- javax/jmdns/impl/tasks/Prober.java	6 Feb 2008 21:42:39 -0000	1.1
+++ javax/jmdns/impl/tasks/Prober.java	1 Mar 2008 13:37:07 -0000
@@ -4,14 +4,6 @@
 
 package javax.jmdns.impl.tasks;
 
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 import javax.jmdns.impl.DNSConstants;
 import javax.jmdns.impl.DNSOutgoing;
 import javax.jmdns.impl.DNSQuestion;
@@ -19,6 +11,13 @@
 import javax.jmdns.impl.DNSState;
 import javax.jmdns.impl.JmDNSImpl;
 import javax.jmdns.impl.ServiceInfoImpl;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * The Prober sends three consecutive probes for all service infos
@@ -69,26 +68,33 @@
 
     public void start(Timer timer)
     {
-        long now = System.currentTimeMillis();
-        if (now - this.jmDNSImpl.getLastThrottleIncrement() < DNSConstants.PROBE_THROTTLE_COUNT_INTERVAL)
-        {
-            this.jmDNSImpl.setThrottle(this.jmDNSImpl.getThrottle() + 1);
-        }
-        else
-        {
-            this.jmDNSImpl.setThrottle(1);
-        }
-        this.jmDNSImpl.setLastThrottleIncrement(now);
-
-        if (this.jmDNSImpl.getState() == DNSState.ANNOUNCED && this.jmDNSImpl.getThrottle() < DNSConstants.PROBE_THROTTLE_COUNT)
-        {
-            timer.schedule(this, JmDNSImpl.getRandom().nextInt(1 + DNSConstants.PROBE_WAIT_INTERVAL), DNSConstants.PROBE_WAIT_INTERVAL);
-        }
-        else
-        {
-            timer.schedule(this, DNSConstants.PROBE_CONFLICT_INTERVAL, DNSConstants.PROBE_CONFLICT_INTERVAL);
-        }
-    }
+		try
+		{
+			long now = System.currentTimeMillis();
+			if (now - this.jmDNSImpl.getLastThrottleIncrement() < DNSConstants.PROBE_THROTTLE_COUNT_INTERVAL)
+			{
+				this.jmDNSImpl.setThrottle(this.jmDNSImpl.getThrottle() + 1);
+			}
+			else
+			{
+				this.jmDNSImpl.setThrottle(1);
+			}
+			this.jmDNSImpl.setLastThrottleIncrement(now);
+
+			if (this.jmDNSImpl.getState() == DNSState.ANNOUNCED && this.jmDNSImpl.getThrottle() < DNSConstants.PROBE_THROTTLE_COUNT)
+			{
+				timer.schedule(this, JmDNSImpl.getRandom().nextInt(1 + DNSConstants.PROBE_WAIT_INTERVAL), DNSConstants.PROBE_WAIT_INTERVAL);
+			}
+			else
+			{
+				timer.schedule(this, DNSConstants.PROBE_CONFLICT_INTERVAL, DNSConstants.PROBE_CONFLICT_INTERVAL);
+			}
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}
+	}
 
     public boolean cancel()
     {
Index: javax/jmdns/impl/tasks/RecordReaper.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/RecordReaper.java,v
retrieving revision 1.1
diff -u -r1.1 RecordReaper.java
--- javax/jmdns/impl/tasks/RecordReaper.java	6 Feb 2008 21:42:40 -0000	1.1
+++ javax/jmdns/impl/tasks/RecordReaper.java	1 Mar 2008 13:37:07 -0000
@@ -4,6 +4,11 @@
 
 package javax.jmdns.impl.tasks;
 
+import javax.jmdns.impl.DNSCache;
+import javax.jmdns.impl.DNSConstants;
+import javax.jmdns.impl.DNSRecord;
+import javax.jmdns.impl.DNSState;
+import javax.jmdns.impl.JmDNSImpl;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -11,12 +16,6 @@
 import java.util.TimerTask;
 import java.util.logging.Logger;
 
-import javax.jmdns.impl.DNSCache;
-import javax.jmdns.impl.DNSConstants;
-import javax.jmdns.impl.DNSRecord;
-import javax.jmdns.impl.DNSState;
-import javax.jmdns.impl.JmDNSImpl;
-
 /**
  * Periodicaly removes expired entries from the cache.
  */
@@ -39,8 +38,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.RECORD_REAPER_INTERVAL, DNSConstants.RECORD_REAPER_INTERVAL);
-    }
+        try
+		{
+			timer.schedule(this, DNSConstants.RECORD_REAPER_INTERVAL, DNSConstants.RECORD_REAPER_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}		
+	}
 
     public void run()
     {
Index: javax/jmdns/impl/tasks/Renewer.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/Renewer.java,v
retrieving revision 1.1
diff -u -r1.1 Renewer.java
--- javax/jmdns/impl/tasks/Renewer.java	6 Feb 2008 21:42:39 -0000	1.1
+++ javax/jmdns/impl/tasks/Renewer.java	1 Mar 2008 13:37:07 -0000
@@ -4,6 +4,11 @@
 
 package javax.jmdns.impl.tasks;
 
+import javax.jmdns.impl.DNSConstants;
+import javax.jmdns.impl.DNSOutgoing;
+import javax.jmdns.impl.DNSState;
+import javax.jmdns.impl.JmDNSImpl;
+import javax.jmdns.impl.ServiceInfoImpl;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -12,12 +17,6 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.jmdns.impl.DNSConstants;
-import javax.jmdns.impl.DNSOutgoing;
-import javax.jmdns.impl.DNSState;
-import javax.jmdns.impl.JmDNSImpl;
-import javax.jmdns.impl.ServiceInfoImpl;
-
 /**
  * The Renewer is there to send renewal announcment when the record expire for ours infos.
  */
@@ -58,8 +57,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.ANNOUNCED_RENEWAL_TTL_INTERVAL, DNSConstants.ANNOUNCED_RENEWAL_TTL_INTERVAL);
-    }
+		try
+		{
+			timer.schedule(this, DNSConstants.ANNOUNCED_RENEWAL_TTL_INTERVAL, DNSConstants.ANNOUNCED_RENEWAL_TTL_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}		
+	}
 
     public boolean cancel()
     {
Index: javax/jmdns/impl/tasks/ServiceInfoResolver.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/ServiceInfoResolver.java,v
retrieving revision 1.1
diff -u -r1.1 ServiceInfoResolver.java
--- javax/jmdns/impl/tasks/ServiceInfoResolver.java	6 Feb 2008 21:42:40 -0000	1.1
+++ javax/jmdns/impl/tasks/ServiceInfoResolver.java	1 Mar 2008 13:37:33 -0000
@@ -4,11 +4,6 @@
 
 package javax.jmdns.impl.tasks;
 
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 import javax.jmdns.impl.DNSConstants;
 import javax.jmdns.impl.DNSOutgoing;
 import javax.jmdns.impl.DNSQuestion;
@@ -16,6 +11,10 @@
 import javax.jmdns.impl.DNSState;
 import javax.jmdns.impl.JmDNSImpl;
 import javax.jmdns.impl.ServiceInfoImpl;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * The ServiceInfoResolver queries up to three times consecutively for
@@ -49,8 +48,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
-    }
+		try
+		{
+			timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}		
+	}
 
     public void run()
     {
Index: javax/jmdns/impl/tasks/ServiceResolver.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/ServiceResolver.java,v
retrieving revision 1.1
diff -u -r1.1 ServiceResolver.java
--- javax/jmdns/impl/tasks/ServiceResolver.java	6 Feb 2008 21:42:40 -0000	1.1
+++ javax/jmdns/impl/tasks/ServiceResolver.java	1 Mar 2008 13:38:21 -0000
@@ -4,13 +4,6 @@
 
 package javax.jmdns.impl.tasks;
 
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 import javax.jmdns.impl.DNSConstants;
 import javax.jmdns.impl.DNSOutgoing;
 import javax.jmdns.impl.DNSQuestion;
@@ -18,6 +11,12 @@
 import javax.jmdns.impl.DNSState;
 import javax.jmdns.impl.JmDNSImpl;
 import javax.jmdns.impl.ServiceInfoImpl;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * The ServiceResolver queries three times consecutively for services of
@@ -49,8 +48,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
-    }
+		try
+		{
+			timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}		
+	}
 
     public void run()
     {
Index: javax/jmdns/impl/tasks/TypeResolver.java
===================================================================
RCS file: /cvsroot/jmdns/jmdns/src/javax/jmdns/impl/tasks/TypeResolver.java,v
retrieving revision 1.1
diff -u -r1.1 TypeResolver.java
--- javax/jmdns/impl/tasks/TypeResolver.java	6 Feb 2008 21:42:40 -0000	1.1
+++ javax/jmdns/impl/tasks/TypeResolver.java	1 Mar 2008 13:38:21 -0000
@@ -4,18 +4,17 @@
 
 package javax.jmdns.impl.tasks;
 
-import java.util.Iterator;
-import java.util.Timer;
-import java.util.TimerTask;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
 import javax.jmdns.impl.DNSConstants;
 import javax.jmdns.impl.DNSOutgoing;
 import javax.jmdns.impl.DNSQuestion;
 import javax.jmdns.impl.DNSRecord;
 import javax.jmdns.impl.DNSState;
 import javax.jmdns.impl.JmDNSImpl;
+import java.util.Iterator;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 /**
  * Helper class to resolve service types.
@@ -44,8 +43,15 @@
 
     public void start(Timer timer)
     {
-        timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
-    }
+		try
+		{
+			timer.schedule(this, DNSConstants.QUERY_WAIT_INTERVAL, DNSConstants.QUERY_WAIT_INTERVAL);
+		}
+		catch(IllegalStateException ex)
+		{
+			logger.fine("Timer was already stopped.");
+		}		
+	}
 
     /**
      * Counts the number of queries that were sent.
